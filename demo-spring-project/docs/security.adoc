= Идентификация Аутентификация Авторизация

Идентификация — это заявление о том, кем вы являетесь. В зависимости от ситуации, это может быть имя, адрес электронной почты, номер учетной записи, и т.д.
Аутентификация — предоставление доказательств и проверка, что вы на самом деле есть тот, кем идентифицировались (от слова “authentic” — истинный, подлинный).
Авторизация — проверка, что вам разрешен доступ к запрашиваемому ресурсу.

В компьютерных системах под идентификацией понимают получение вашей учетной записи (identity) по username или email; под аутентификацией — проверку, что вы знаете пароль от этой учетной записи, а под авторизацией — проверку вашей роли в системе и решение о предоставлении доступа к запрошенной странице или ресурсу.

== Аутентификация по паролю (пользователь должен предоставить username и password)
=== HTTP authentication
Сервер, при обращении неавторизованного клиента к защищенному ресурсу, отсылает HTTP статус “401 Unauthorized” и добавляет заголовок “WWW-Authenticate” с указанием схемы и параметров аутентификации.
Браузер, при получении такого ответа, автоматически показывает диалог ввода username и password. Пользователь вводит детали своей учетной записи.
Во всех последующих запросах к этому веб-сайту браузер автоматически добавляет HTTP заголовок “Authorization”, в котором передаются данные пользователя для аутентификации сервером.
Сервер аутентифицирует пользователя по данным из этого заголовка. Решение о предоставлении доступа (авторизация) производится отдельно на основании роли пользователя, ACL или других данных учетной записи.

==== Basic
наиболее простая схема, при которой username и password пользователя передаются в заголовке Authorization в незашифрованном виде (base64-encoded). Однако при использовании HTTPS (HTTP over SSL) протокола, является относительно безопасной.
(добавить скрин)

==== Digest
challenge-response-схема: MD5 хэширование пароля с помощью nonce параметра от сервера

==== NTLM (Windows authentication)
==== Negotiate (тоже из семейства Windows authentication)

=== Forms authentication
Работает это по следующему принципу: в веб-приложение включается HTML-форма, в которую пользователь должен ввести свои username/password и отправить их на сервер через HTTP POST для аутентификации. В случае успеха веб-приложение создает session token, который обычно помещается в browser cookies. При последующих веб-запросах session token автоматически передается на сервер и позволяет приложению получить информацию о текущем пользователе для авторизации запроса
(скрин)

=== Другие протоколы аутентификации по паролю
где можно передать username и password в HTTP запросах:

URL query — считается небезопасным вариантом, т. к. строки URL могут запоминаться браузерами, прокси и веб-серверами.
Request body — безопасный вариант, но он применим только для запросов, содержащих тело сообщения (такие как POST, PUT, PATCH).
HTTP header —оптимальный вариант, при этом могут использоваться и стандартный заголовок Authorization (например, с Basic-схемой), и другие произвольные заголовки.

== Аутентификация по сертификатам
В веб-приложениях традиционно используют сертификаты стандарта X.509.

== Аутентификация по одноразовым паролям
Аутентификация по одноразовым паролям обычно применяется дополнительно к аутентификации по паролям для реализации two-factor authentication (2FA). В этой концепции пользователю необходимо предоставить данные двух типов для входа в систему: что-то, что он знает (например, пароль), и что-то, чем он владеет (например, устройство для генерации одноразовых паролей). Наличие двух факторов позволяет в значительной степени увеличить уровень безопасности, что м. б. востребовано для определенных видов веб-приложений.

Другой популярный сценарий использования одноразовых паролей — дополнительная аутентификация пользователя во время выполнения важных действий: перевод денег, изменение настроек и т. п.

== Аутентификация по ключам доступа
Этот способ чаще всего используется для аутентификации устройств, сервисов или других приложений при обращении к веб-сервисам. Здесь в качестве секрета применяются ключи доступа (access key, API key) — длинные уникальные строки, содержащие произвольный набор символов, по сути заменяющие собой комбинацию username/password.

== Аутентификация по токенам
Примечание: Технология единого входа (Single sign-on SSO) — метод аутентификации, который позволяет пользователям безопасно аутентифицироваться сразу в нескольких приложениях и сайтах, используя один набор учетных данных.
Делегированная аутентификация пользователей; делегированная авторизация приложений

Такой способ аутентификации чаще всего применяется при построении распределенных систем Single Sign-On (SSO), где одно приложение (service provider или relying party) делегирует функцию аутентификации пользователей другому приложению (identity provider или authentication service). Типичный пример этого способа — вход в приложение через учетную запись в социальных сетях. Здесь социальные сети являются сервисами аутентификации, а приложение доверяет функцию аутентификации пользователей социальным сетям.

Реализация этого способа заключается в том, что identity provider (IP) предоставляет достоверные сведения о пользователе в виде токена, а service provider (SP) приложение использует этот токен для идентификации, аутентификации и авторизации пользователя.
На общем уровне, весь процесс выглядит следующим образом:

Клиент аутентифицируется в identity provider одним из способов, специфичным для него (пароль, ключ доступа, сертификат, Kerberos, итд.).
Клиент просит identity provider предоставить ему токен для конкретного SP-приложения. Identity provider генерирует токен и отправляет его клиенту.
Клиент аутентифицируется в SP-приложении при помощи этого токена.

Сам токен обычно представляет собой структуру данных, которая содержит информацию, кто сгенерировал токен, кто может быть получателем токена, срок действия, набор сведений о самом пользователе (claims).

OAuth, SAML

OAuth2: Ключевая цель процесса – предоставить клиенту (в нашем случае Facebook, service provider) доступ к данным, не раскрывая пароля.
Клиент должен получить от авторизационного сервера (identity provider) специальный токен доступа (access token). Этот токен позволяет запрашивать данные у сервера ресурсов, но ограничивает доступ в соответствии с заданными разрешениями.

== Spring security
image::multi-securityfilterchain.png[]
=== DelegatingFilterProxy
Связующее звено между контейнером сервлетов и Spring Application Context.
Отвечает за подключение любого класса, реализующего javax.servlet.Filter, к цепочке фильтров.

=== FilterChainProxy
Spring Security внутренне создаёт компонент FilterChainProxy с именем springSecurityFilterChain, заключённый в DelegatingFilterProxy. FilterChainProxy — это фильтр, объединяющий несколько фильтров в цепочку в соответствии с конфигурацией безопасности. Таким образом, DelegatingFilterProxy делегирует запрос FilterChainProxy, который определяет, какие фильтры нужно вызвать.

=== SecurityFilterChain
Фильтры безопасности в SecurityFilterChain — это компоненты, зарегистрированные в FilterChainProxy. В приложении может быть несколько SecurityFilterChain. FilterChainProxy использует интерфейс RequestMatcher в HttpServletRequest, чтобы определить, какой SecurityFilterChain нужно вызвать.

=== Фильтры безопасности
* CsrfFilter
* LogoutFilter
* UsernamePasswordAuthenticationFilter +
HttpSecurity#formLogin +
impl. AbstractAuthenticationProcessingFilter +
UsernamePasswordAuthenticationToken (impl. Authentication) +
попытка аутентификации через AuthenticationManager
* BasicAuthenticationFilter +
HttpSecurity#httpBasic
* RequestHeaderAuthenticationFilter +
impl. AbstractPreAuthenticatedProcessingFilter, +
PreAuthenticatedAuthenticationToken (impl. Authentication) +
попытка аутентификации через AuthenticationManager
* AuthorizationFilter +
HttpSecurity#authorizeHttpRequests
* ExceptionTranslationFilter +
позволяет преобразовывать AccessDeniedException и AuthenticationException в HTTP-ответы

=== Добавление своего фильтра
HttpSecurity
#addFilterBefore(Filter, Class<?>)
#addFilterAfter(Filter, Class<?>)
#addFilterAt(Filter, Class<?>) - заменяет другой

=== Общий алгоритм аутентификации
Приходящий http-запрос перед тем, как попасть в контроллер проходит цепочку фильтров:
из него извлекаются логин/пароль (в Складе - токен) и формируется объект Authentication (логин в principal,
пароль в credentials).
Далее нужно сравнить их с реальными логином/паролем (из БД/внешней системы и т.п), и AuthenticationManager (его реализация ProviderManager)
делегирует это своим провайдерам AuthenticationProvider, которые могут использовать UserDetailsService для извлечения UserDetails
(если данные о пользователе не найдены - UsernameNotFoundException).
И провайдер, и userDetailsService получают реально существующий логин/пароль, а вот сравнение с пришедшими на проверку
делает только провайдер - формируется объект Authentication, где реальный пользователь лежит в principal в виде UserDetails
(либо выбрасывается исключение AuthenticationException). Секретные данные очищаются.
Допустим, аутентификация прошла успешно — это значит, имя и пароль верные.
Тогда объект Authentication сохраняется в SecurityContext, а тот, в свою очередь, — в SecurityContextHolder.

=== Username/Password Authentication
* Form Login +
фильтр UsernamePasswordAuthenticationFilter (реализация AbstractAuthenticationProcessingFilter) извлекает логин/пароль из запроса HttpServletRequest,
создает UsernamePasswordAuthenticationToken (реализация Authentication) и передает его в AuthenticationManager, которые делегирует его провайдеру DaoAuthenticationProvider
(реализация AuthenticationProvider), который ищет информацию о пользователе (UserDetails) с помощью UserDetailsService и аутентифицирует его,
заполняя в UsernamePasswordAuthenticationToken principal = UserDetails. Секретные данные очищаются.

=== Варианты AuthenticationProvider
DaoAuthenticationProvider
JwtAuthenticationProvider
LdapAuthenticationProvider
PreAuthenticatedAuthenticationProvider

=== Реализации UserDetailsService
InMemoryUserDetailsManager
JdbcUserDetailsManager extends JdbcDaoImpl

=== @EnableWebSecurity
Объявляет бины: +
SecurityFilterChain (помимо всего прочего)
UserDetailsService
AuthenticationEventPublisher