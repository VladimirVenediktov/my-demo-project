== Синхронизированные коллекции
Collections.synchronizedList()
Collections.synchronizedMap()
и др. Collections.synchronizedXXX()

. с коллекцией одновременно может работать только 1 поток (происходит блокировка всей коллекции)
. хотя простые методы (get/put) уже синхронизированы, все еще требуется дополнительная синхронизация для других операций; например, методу типа "добавить-если-отсутствует" (put-if-absent)
. для небольшого количества потоков подойдет, но при большом количестве потоков производительность будет низкой

== ConcurrentHashMap
из java.util.concurrent
потокобезопасная реализация Map, которая предоставляет намного большую степень масштабирования (параллелизма), чем synchronizedMap +
СoncurrentHashMap использует несколько сегментов (новый слой абстракции - Segment), и данный класс нужно рассматривать как группу HashMap’ов. Количество сегментов по умолчанию равно 16. Если пара key-value хранится в 10-ом сегменте, то ConcurrentHashMap заблокирует только 10-й сегмент, и не будет блокировать остальные 15.

примеры методов:

. putIfAbsent (K, V) - добавляет новую пару key-value только в том случае, если в коллекции нет значения с данным ключом, и возвращает предыдущее значение для заданного ключа
. remove(K, V) - удаляет пару key-value только в том случае, если заданному ключу соответствует значение в коллекции Map, и возвращает true, если элемент был успешно удален
. replace(K, V) - заменяет значение для заданного ключа, если в коллекции уже есть значение для этого ключа, и возвращает true, если замена прошла успешно

== CopyOnWriteArrayList
следует использовать вместо ArrayList в потоконагруженных приложениях, где могут иметь место нечастые операции вставки и удаления в одних потоках и одновременный перебор в других. Это типично для случая, когда коллекция ArrayList используется для хранения списка объектов. +
CopyOnWriteArrayList создаёт новую копию списка при выполнении модифицирующей операции и гарантирует, что её итераторы вернут состояние списка на момент создания итератора и не выкинут ConcurrentModificationException. Это так называемый алгоритм CopyOnWrite. Нет необходимости клонировать список до перебора или блокировать его во время перебора, т.к. используемая итератором копия списка изменяться не будет.
