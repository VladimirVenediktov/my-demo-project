Партиционирование (вертикальный шардинг) — это разбиение таблиц, содержащих большое количество записей,
на логические части по некоторому критерию, ключу (зачастую дата).
В postgres:

. по диапазонам
. по списку (явно указывающему какие значения должны относится к каждой секции)
. по хэшу

Декларативное/ Ч-з наследование

Партиционирование таблиц делит весь объем операций по обработке данных на несколько независимых
и параллельно выполняющихся потоков, что существенно ускоряет работу с БД.

Что дает:

. Увеличение производительности: когда в выборке или изменении данных задействована большая часть одной секции,
последовательное сканирование этой секции может выполняться гораздо быстрее, чем случайный доступ по индексу к данным,
разбросанным по всей таблице, быстрее обновляются индексы для более мелких таблиц,
массовую загрузку и удаление данных можно осуществлять, добавляя и удаляя секции, что тоже оптимальнее,
чем выполнять это на всей огромной таблице (vacuum)

. Экономия ресурсов (хранение старых данных на медленных носителях)

Партиционировать стоит те таблицы, размер которых превышает объем оперативной памяти сервера более, чем в 3 раза,
однако, в общем случае, если таблица превысила размер а 50GB.

Партицирование применяется на одном инстансе — это тот же самый инстанс БД, где у вас лежала бы большая толстая таблица,
но мы ее раздробили на мелкие части.
Шардинг — это прием, который позволяет распределять данные между разными физическими серверами.
Процесс шардинга предполагает разнесения данных между отдельными шардами на основе некого ключа шардинга.
Репликация — это синхронное или асинхронное копирование данных между несколькими серверами.
Ведущие сервера называют мастерами (master), а ведомые сервера — слэйвами (slave).
Мастера используются для изменения данных, а слэйвы — для чтения.

* Единственное отличие горизонтального масштабирования от вертикального в том,
что горизонтальное масштабирование будет разносить данные по разным инстансам.

Партиционирование pg_partman:

. создаем партиционированную родительскую таблицу
. создаем неуникальные индексы для нее
. создаем template-таблицу для уникальных индексов
. добавляем ей уник. индексы
. задаем настройки партиционирования SELECT partman.create_parent('public.part_table_1',
                                                                  'date_created',
                                                                  'native',
                                                                  'daily',
                                                                  p_start_partition := '2023-01-23',
                                                                  p_template_table := 'public.part_table_1_template',
                                                                  p_premake := 3)
. проверяем SELECT * FROM partman.part_config where parent_table = 'public.part_table_1';
. заполняем имеющимися данными из непартиционированной таблицы:
COPY () TO и COPY FROM
CALL partman.partition_data_proc()
INSERT INTO original_table
SELECT * FROM old_nonpartitioned_table)

* Все non-unique индексы родительской таблицы parent будут создаваться автоматом и в дочерних (для PG11+)
А вот для уникальных (Primary key, Unique constraint) поможет template-таблица.

В случаях, когда в таблице часто выполняются запросы, которые не содержат ключа секционирования и затрагивающие все разделы,
секционирование может приводить к снижению производительности доступа в несколько раз.
