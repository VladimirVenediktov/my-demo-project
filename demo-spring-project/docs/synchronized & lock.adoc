Использование изменяемой переменной несколькими потоками без синхронизации приводит к состоянию гонки (race condition)

Ключевое слово synchronized на методе или блоке кода, который может выполняться только 1 потоком одновременно.
Под капотом Java использует так называемый монитор (monitor lock, intrinsic lock) для обеспечения синхронизации.
Все неявные мониторы устроены реентерабельно (reentrant), т.е. таким образом, что поток может без проблем вызывать
блокировку одного и того же объекта, исключая взаимную блокировку (например, когда синхронизированный метод вызывает
другой синхронизированный метод на том же объекте).

Явные блокировки
Concurrency API предоставляет интерфейс Lock и его реализации, такие как ReentrantLock, ReadWriteLock, StampedLock и другие.
lock() - блокировка,
unlock() - разблокировка
Только один поток может удерживать блокировку в каждый момент времени.
Метод tryLock(), в отличие от обычного lock() не останавливает текущий поток в случае, если ресурс уже занят.
Он возвращает булевый результат, который стоит проверить перед тем, как пытаться производить какие-то действия с общими объектами
(истина обозначает, что контроль над ресурсами захватить удалось).

ReadWriteLock предлагает другой тип блокировок — отдельную для чтения, и отдельную для записи.
Этот интерфейс был добавлен из соображения, что считывать данные (любому количеству потоков) безопасно до тех пор, пока ни один из них не изменяет переменную.
Таким образом, блокировку для чтения (read-lock) может удерживать любое количество потоков до тех пор, пока не удерживает блокировка для записи (write-lock).
Такой подход может увеличить производительность в случае, когда чтение используется гораздо чаще, чем запись.
